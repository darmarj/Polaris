{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"architecture/","text":"Abstract \u00b6 A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond. Architecture \u00b6","title":"Architecture"},{"location":"architecture/#abstract","text":"A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.","title":"Abstract"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"containerd/","text":"Abstract \u00b6 Containerd \u2013 An abstraction of kernel features that provides a relatively high level container interface. Other software projects can use this to run containers and manage container images. Ecosystem Container Runtime Interface (CRI) \u00b6 CRI is the API that Kubernetes uses to control the different runtimes that create and manage containers. CRI makes it easier for Kubernetes to use different container runtimes. Instead of the Kubernetes project having to manually add support for each runtime, the CRI API describes how Kubernetes interacts with each runtime. So it\u2019s up to the runtime how to actually manage containers, as long as it obeys the CRI API. So if you prefer to use containerd to run your containers, you can. Or, if you prefer to use CRI-O , then you can. This is because both of these runtimes implement the CRI spec. If you\u2019re an end user, the implementation mostly shouldn\u2019t matter. These CRI implementations are intended to be pluggable and seamlessly changeable. Your choice of runtime might be important if you pay to get support (security, bug fixes etc) from a vendor. For example, Red Hat\u2019s OpenShift uses CRI-O , and offers support for it. Docker provides support for their own containerd . How to check your container runtime in Kubernetes? In Kubernetes architecture, the kubelet (the agent that runs on each node) is responsible for sending instructions to the container runtime to start and run containers. You can check which container runtime you\u2019re using by looking at the kubelet parameters on each node. There\u2019s an option --container-runtime and --container-runtime-endpoint which are used to configure which runtime to use. Containerd \u00b6 containerd is a high-level container runtime that came from Docker, and implements the CRI spec. It pulls images from registries, manages them and then hands over to a lower-level runtime, which actually creates and runs the container processes. containerd was separated out of the Docker project, to make Docker more modular. So Docker uses containerd internally itself. When you install Docker, it will also install containerd. containerd implements the Kubernetes Container Runtime Interface (CRI), via its cri plugin. CRI-O \u00b6 CRI-O is another high-level container runtime which implements the Container Runtime Interface (CRI). It\u2019s an alternative to containerd. It pulls container images from registries, manages them on disk, and launches a lower-level runtime to run container processes. Yes, CRI-O is another container runtime. It was born out of Red Hat, IBM, Intel, SUSE and others. It was specifically created from the ground up as a container runtime for Kubernetes. It provides the ability to start, stop and restart containers, just like containerd. Open Container Initiative (OCI) \u00b6 The OCI is a group of tech companies who maintain a specification for the container image format, and how containers should be run. The idea behind the OCI is that you can choose between different runtimes which conform to the spec. Each of these runtimes have different lower-level implementations. For example, you might have one OCI-compliant runtime for your Linux hosts, and one for your Windows hosts. This is the benefit of having one standard that can be implemented by many different projects. This same \u201cone standard, many implementations\u201d approach is in use everywhere, from Bluetooth devices to Java APIs. runc \u00b6 runc is an OCI-compatible container runtime. It implements the OCI specification and runs the container processes. runc is called the reference implementation of OCI. What is a reference implementation? A reference implementation is a piece of software that has implemented all the requirements of a specification or standard. It\u2019s usually the first piece of software which is developed from the specification. In the case of OCI, runc provides all the features expected of an OCI-compliant runtime, although anyone can implement their own OCI runtime if they like. runc provides all of the low-level functionality for containers, interacting with existing low-level Linux features, like namespaces and control groups. It uses these features to create and run container processes. A couple of alternatives to runc are: crun a container runtime written in C (by contrast, runc is written in Go.) kata-runtime from the Katacontainers project, which implements the OCI specification as individual lightweight VMs (hardware virtualisation gVisor from Google, which creates containers that have their own kernel. It implements OCI in its runtime called runsc. What's the equivalent of runc on Windows? runc is a tool for running containers on Linux. So that means it runs on Linux, on bare metal or inside a VM. On Windows, it\u2019s slightly different. The equivalent of runc is Microsoft\u2019s Host Compute Service (HCS). It includes a tool called runhcs, which itself is a fork of runc, and also implements the Open Container Initiative specification.","title":"Containerd"},{"location":"containerd/#abstract","text":"Containerd \u2013 An abstraction of kernel features that provides a relatively high level container interface. Other software projects can use this to run containers and manage container images. Ecosystem","title":"Abstract"},{"location":"containerd/#container-runtime-interface-cri","text":"CRI is the API that Kubernetes uses to control the different runtimes that create and manage containers. CRI makes it easier for Kubernetes to use different container runtimes. Instead of the Kubernetes project having to manually add support for each runtime, the CRI API describes how Kubernetes interacts with each runtime. So it\u2019s up to the runtime how to actually manage containers, as long as it obeys the CRI API. So if you prefer to use containerd to run your containers, you can. Or, if you prefer to use CRI-O , then you can. This is because both of these runtimes implement the CRI spec. If you\u2019re an end user, the implementation mostly shouldn\u2019t matter. These CRI implementations are intended to be pluggable and seamlessly changeable. Your choice of runtime might be important if you pay to get support (security, bug fixes etc) from a vendor. For example, Red Hat\u2019s OpenShift uses CRI-O , and offers support for it. Docker provides support for their own containerd . How to check your container runtime in Kubernetes? In Kubernetes architecture, the kubelet (the agent that runs on each node) is responsible for sending instructions to the container runtime to start and run containers. You can check which container runtime you\u2019re using by looking at the kubelet parameters on each node. There\u2019s an option --container-runtime and --container-runtime-endpoint which are used to configure which runtime to use.","title":"Container Runtime Interface (CRI)"},{"location":"containerd/#containerd","text":"containerd is a high-level container runtime that came from Docker, and implements the CRI spec. It pulls images from registries, manages them and then hands over to a lower-level runtime, which actually creates and runs the container processes. containerd was separated out of the Docker project, to make Docker more modular. So Docker uses containerd internally itself. When you install Docker, it will also install containerd. containerd implements the Kubernetes Container Runtime Interface (CRI), via its cri plugin.","title":"Containerd"},{"location":"containerd/#cri-o","text":"CRI-O is another high-level container runtime which implements the Container Runtime Interface (CRI). It\u2019s an alternative to containerd. It pulls container images from registries, manages them on disk, and launches a lower-level runtime to run container processes. Yes, CRI-O is another container runtime. It was born out of Red Hat, IBM, Intel, SUSE and others. It was specifically created from the ground up as a container runtime for Kubernetes. It provides the ability to start, stop and restart containers, just like containerd.","title":"CRI-O"},{"location":"containerd/#open-container-initiative-oci","text":"The OCI is a group of tech companies who maintain a specification for the container image format, and how containers should be run. The idea behind the OCI is that you can choose between different runtimes which conform to the spec. Each of these runtimes have different lower-level implementations. For example, you might have one OCI-compliant runtime for your Linux hosts, and one for your Windows hosts. This is the benefit of having one standard that can be implemented by many different projects. This same \u201cone standard, many implementations\u201d approach is in use everywhere, from Bluetooth devices to Java APIs.","title":"Open Container Initiative (OCI)"},{"location":"containerd/#runc","text":"runc is an OCI-compatible container runtime. It implements the OCI specification and runs the container processes. runc is called the reference implementation of OCI. What is a reference implementation? A reference implementation is a piece of software that has implemented all the requirements of a specification or standard. It\u2019s usually the first piece of software which is developed from the specification. In the case of OCI, runc provides all the features expected of an OCI-compliant runtime, although anyone can implement their own OCI runtime if they like. runc provides all of the low-level functionality for containers, interacting with existing low-level Linux features, like namespaces and control groups. It uses these features to create and run container processes. A couple of alternatives to runc are: crun a container runtime written in C (by contrast, runc is written in Go.) kata-runtime from the Katacontainers project, which implements the OCI specification as individual lightweight VMs (hardware virtualisation gVisor from Google, which creates containers that have their own kernel. It implements OCI in its runtime called runsc. What's the equivalent of runc on Windows? runc is a tool for running containers on Linux. So that means it runs on Linux, on bare metal or inside a VM. On Windows, it\u2019s slightly different. The equivalent of runc is Microsoft\u2019s Host Compute Service (HCS). It includes a tool called runhcs, which itself is a fork of runc, and also implements the Open Container Initiative specification.","title":"runc"},{"location":"docker/","text":"Abstract \u00b6 Docker \u2013 A developer-oriented software with a high level interface that lets you easily build and run containers from your terminal. It now uses containerd as its container runtime. We have to start with Docker because it\u2019s the most popular developer tool for working with containers. And for a lot of people, the name \u201cDocker\u201d itself is synonymous with the word \u201ccontainer\u201d. Docker kick-started this whole revolution. Docker created a very ergonomic (nice-to-use) tool for working with containers \u2013 also called docker . Container in Docker \u00b6 docker is designed to be installed on a workstation or server and comes with a bunch of tools to make it easy to build and run containers as a developer, or DevOps person. The docker command line tool can build container images, pull them from registries, create, start and manage containers. To make all of this happen, the experience you know as docker is now comprised of these projects (there are others, but these are the main ones): docker-cli: This is the command-line utility that you interact with using docker ... commands. containerd: This is a daemon process that manages and runs containers. It pushes and pulls images, manages storage and networking, and supervises the running of containers. runc: This is the low-level container runtime (the thing that actually creates and runs containers). It includes libcontainer, a native Go-based implementation for creating containers. In reality, when you run a container with docker , you\u2019re actually running it through the Docker daemon, containerd, and then runc. Dockershim: Docker in Kubernetes \u00b6 Kubernetes includes a component called dockershim , which allows it to support Docker. Kubernetes prefers to run containers through any container runtime which supports its Container Runtime Interface (CRI) . But Docker, being older than Kubernetes, doesn\u2019t implement CRI. So that\u2019s why the dockershim exists, to basically bolt Docker onto Kubernetes. Or Kubernetes onto Docker, whichever way round you prefer to think of it. What is a shim? In tech terms, a shim is a component in a software system, which acts as a bridge between different APIs, or as a compatibility layer. A shim is sometimes added when you want to use a third-party component, but you need a little bit of glue code to make it work. Going forward, Kubernetes will remove support for Docker directly, and prefer to use only container runtimes that implement its Container Runtime Interface. This probably means using containerd or CRI-O. But this doesn\u2019t mean that Kubernetes won\u2019t be able to run Docker-formatted containers . Both containerd and CRI-O can run Docker-formatted (actually OCI-formatted) images, they just do it without having to use the docker command or the Docker daemon. Phew. Hope that cleared that up. Docker images \u00b6 What many people refer to as Docker images, are actually images packaged in the Open Container Initiative (OCI) format. So if you pull an image from Docker Hub, or another registry, you should be able to use it with the docker command, or on a Kubernetes cluster, or with the podman utility, or any other tool that supports the OCI image format spec.","title":"Docker"},{"location":"docker/#abstract","text":"Docker \u2013 A developer-oriented software with a high level interface that lets you easily build and run containers from your terminal. It now uses containerd as its container runtime. We have to start with Docker because it\u2019s the most popular developer tool for working with containers. And for a lot of people, the name \u201cDocker\u201d itself is synonymous with the word \u201ccontainer\u201d. Docker kick-started this whole revolution. Docker created a very ergonomic (nice-to-use) tool for working with containers \u2013 also called docker .","title":"Abstract"},{"location":"docker/#container-in-docker","text":"docker is designed to be installed on a workstation or server and comes with a bunch of tools to make it easy to build and run containers as a developer, or DevOps person. The docker command line tool can build container images, pull them from registries, create, start and manage containers. To make all of this happen, the experience you know as docker is now comprised of these projects (there are others, but these are the main ones): docker-cli: This is the command-line utility that you interact with using docker ... commands. containerd: This is a daemon process that manages and runs containers. It pushes and pulls images, manages storage and networking, and supervises the running of containers. runc: This is the low-level container runtime (the thing that actually creates and runs containers). It includes libcontainer, a native Go-based implementation for creating containers. In reality, when you run a container with docker , you\u2019re actually running it through the Docker daemon, containerd, and then runc.","title":"Container in Docker"},{"location":"docker/#dockershim-docker-in-kubernetes","text":"Kubernetes includes a component called dockershim , which allows it to support Docker. Kubernetes prefers to run containers through any container runtime which supports its Container Runtime Interface (CRI) . But Docker, being older than Kubernetes, doesn\u2019t implement CRI. So that\u2019s why the dockershim exists, to basically bolt Docker onto Kubernetes. Or Kubernetes onto Docker, whichever way round you prefer to think of it. What is a shim? In tech terms, a shim is a component in a software system, which acts as a bridge between different APIs, or as a compatibility layer. A shim is sometimes added when you want to use a third-party component, but you need a little bit of glue code to make it work. Going forward, Kubernetes will remove support for Docker directly, and prefer to use only container runtimes that implement its Container Runtime Interface. This probably means using containerd or CRI-O. But this doesn\u2019t mean that Kubernetes won\u2019t be able to run Docker-formatted containers . Both containerd and CRI-O can run Docker-formatted (actually OCI-formatted) images, they just do it without having to use the docker command or the Docker daemon. Phew. Hope that cleared that up.","title":"Dockershim: Docker in Kubernetes"},{"location":"docker/#docker-images","text":"What many people refer to as Docker images, are actually images packaged in the Open Container Initiative (OCI) format. So if you pull an image from Docker Hub, or another registry, you should be able to use it with the docker command, or on a Kubernetes cluster, or with the podman utility, or any other tool that supports the OCI image format spec.","title":"Docker images"},{"location":"kubernetes/","text":"Abstract Kubernetes \u2013 A container orchestrator that works with multiple container runtimes, including containerd. Kubernetes is focused on deploying containers in aggregate across one or more physical \u201cnodes.\u201d Historically, Kubernetes was tied to Docker. Architecture \u00b6 The Control plane \u00b6 On the left, you\u2019ve got the control plane , which lives across multiple nodes. \u201cControl plane\u201d is a pretty broad term to describe the components that manage the cluster. It includes things like the Kubernetes API Server (which you interact with when you use kubectl ), and Etcd (which is the data store that holds the desired state of the cluster). The nodes \u00b6 The nodes are the worker machines which run your Pods and their containers. On each node, the Kubelet is a clever daemon that manages the containers running on that node, and reports back their status to the control plane. You want to learn more about Kubernetes, check out the components page on the official Kubernetes on the website.","title":"Kubernetes"},{"location":"kubernetes/#architecture","text":"","title":"Architecture"},{"location":"kubernetes/#the-control-plane","text":"On the left, you\u2019ve got the control plane , which lives across multiple nodes. \u201cControl plane\u201d is a pretty broad term to describe the components that manage the cluster. It includes things like the Kubernetes API Server (which you interact with when you use kubectl ), and Etcd (which is the data store that holds the desired state of the cluster).","title":"The Control plane"},{"location":"kubernetes/#the-nodes","text":"The nodes are the worker machines which run your Pods and their containers. On each node, the Kubelet is a clever daemon that manages the containers running on that node, and reports back their status to the control plane. You want to learn more about Kubernetes, check out the components page on the official Kubernetes on the website.","title":"The nodes"},{"location":"blog/","text":".md-sidebar--secondary:not([hidden]) { visibility: hidden; } [Wd Skype] \u00b6 This is the story of the time onboard. Most of in spirite on stay on focus and pay aggressive for the next step! Darmarj M \u00b7 @darmarj November 19, 2021 \u00b7 15 min read \u00b7 [ 7.2.6+insiders-3.0.0][insiders-3.0.0] A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond. Continue reading","title":"Index"},{"location":"blog/#wd-skype","text":"This is the story of the time onboard. Most of in spirite on stay on focus and pay aggressive for the next step! Darmarj M \u00b7 @darmarj November 19, 2021 \u00b7 15 min read \u00b7 [ 7.2.6+insiders-3.0.0][insiders-3.0.0] A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond. Continue reading","title":"[Wd Skype]"},{"location":"blog/2021/CNCF-Containerd/","text":"Cloud Native-Containerd \u00b6 A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond. Architecture \u00b6","title":"Cloud Native-Containerd"},{"location":"blog/2021/CNCF-Containerd/#cloud-native-containerd","text":"A daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.","title":"Cloud Native-Containerd"},{"location":"blog/2021/CNCF-Containerd/#architecture","text":"","title":"Architecture"}]}